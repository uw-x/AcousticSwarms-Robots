/**
 * Copyright (c) 2016 - 2021, Nordic Semiconductor ASA
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form, except as embedded into a Nordic
 *    Semiconductor ASA integrated circuit in a product or a software update for
 *    such product, must reproduce the above copyright notice, this list of
 *    conditions and the following disclaimer in the documentation and/or other
 *    materials provided with the distribution.
 *
 * 3. Neither the name of Nordic Semiconductor ASA nor the names of its
 *    contributors may be used to endorse or promote products derived from this
 *    software without specific prior written permission.
 *
 * 4. This software, with or without modification, must only be used with a
 *    Nordic Semiconductor ASA integrated circuit.
 *
 * 5. Any software provided in binary form under this license must not be reverse
 *    engineered, decompiled, modified and/or disassembled.
 *
 * THIS SOFTWARE IS PROVIDED BY NORDIC SEMICONDUCTOR ASA "AS IS" AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL NORDIC SEMICONDUCTOR ASA OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */
#include <stdio.h>
#include <stdint.h>
#include <stdbool.h>
#include "nordic_common.h"
#include "app_error.h"
#include "app_uart.h"
#include "app_timer.h"
#include "app_util.h"
#include "nrf_drv_clock.h"
#include "nrf_pwr_mgmt.h"
#include "app_usbd.h"

#include "nrf_log.h"
#include "nrf_log_ctrl.h"
#include "nrf_log_default_backends.h"

#include "event.h"
#include "timers.h"
#include "ble_cus.h"
#include "usb.h"
#include "peripheral.h"
#include "bsp_btn_ble.h"

static uint8_t usb_args_buffer[256];
static bool m_ble_tx_sent_requested = false;

#define RUN_TESTS 0

/**@brief Function for handling asserts in the SoftDevice.
 *
 * @details This function is called in case of an assert in the SoftDevice.
 *
 * @warning This handler is only an example and is not meant for the final product. You need to analyze
 *          how your product is supposed to react in case of assert.
 * @warning On assert from the SoftDevice, the system can only recover on reset.
 *
 * @param[in] line_num     Line number of the failing assert call.
 * @param[in] p_file_name  File name of the failing assert call.
 */
void assert_nrf_callback(uint16_t line_num, const uint8_t * p_file_name)
{
    app_error_handler(0xDEADBEEF, line_num, p_file_name);
}

/**
 * @brief Function for handling shutdown events.
 *
 * @param[in]   event       Shutdown type.
 */
static bool shutdown_handler(nrf_pwr_mgmt_evt_t event)
{
    ret_code_t err_code;

    err_code = bsp_indication_set(BSP_INDICATE_IDLE);
    APP_ERROR_CHECK(err_code);

    switch (event)
    {
        case NRF_PWR_MGMT_EVT_PREPARE_WAKEUP:
            // Prepare wakeup buttons.
            err_code = bsp_btn_ble_sleep_mode_prepare();
            APP_ERROR_CHECK(err_code);
            break;

        default:
            break;
    }

    return true;
}

NRF_PWR_MGMT_HANDLER_REGISTER(shutdown_handler, APP_SHUTDOWN_HANDLER_PRIORITY);

/**@brief Function for handling events from the BSP module.
 *
 * @param[in] event  Event generated by button press.
 */
void bsp_event_handler(bsp_event_t event)
{
    ret_code_t err_code;

    switch (event)
    {
        case BSP_EVENT_SLEEP:
            nrf_pwr_mgmt_shutdown(NRF_PWR_MGMT_SHUTDOWN_GOTO_SYSOFF);
            break;

        case BSP_EVENT_DISCONNECT:
            //err_code = sd_ble_gap_disconnect(m_ble_nus_c.conn_handle,
            //                                 BLE_HCI_REMOTE_USER_TERMINATED_CONNECTION);
            if (err_code != NRF_ERROR_INVALID_STATE)
            {
                APP_ERROR_CHECK(err_code);
            }
            break;

        default:
            break;
    }
}

/**@brief Function for initializing buttons and leds. */
static void buttons_leds_init(void)
{
    ret_code_t err_code;
    bsp_event_t startup_event;

    err_code = bsp_init(BSP_INIT_LEDS, bsp_event_handler);
    APP_ERROR_CHECK(err_code);

    err_code = bsp_btn_ble_init(NULL, &startup_event);
    APP_ERROR_CHECK(err_code);
}


/**@brief Function for initializing the nrf log module. */
static void log_init(void)
{
    ret_code_t err_code = NRF_LOG_INIT(NULL);
    APP_ERROR_CHECK(err_code);

    NRF_LOG_DEFAULT_BACKENDS_INIT();
}


/**@brief Function for initializing power management.
 */
static void power_management_init(void)
{
    ret_code_t err_code;
    err_code = nrf_pwr_mgmt_init();
    APP_ERROR_CHECK(err_code);
}

/**@brief Function for handling the idle state (main loop).
 *
 * @details Handles any pending log operations, then sleeps until the next event occurs.
 */
static void idle_state_handle(void)
{
    if (NRF_LOG_PROCESS() == false)
    {
        nrf_pwr_mgmt_run();
    }
}

void processQueue();

#if RUN_TESTS

#include "ringbuffer.h"
#define RB_SIZE (4096*2)
uint8_t _rb_stack[RB_SIZE];

#define TEST_ARR_LENGTH 5000
uint8_t input[TEST_ARR_LENGTH ];
uint8_t output[TEST_ARR_LENGTH ];

bool test_rb_check(ringbuffer_t *r, uint8_t* arr){
  for(int i = 0; i < TEST_ARR_LENGTH; i++){
    if(rb_at(r, i) != arr[i]){
      return false;
    }
  }
  return true;
}


bool test_arrays_equal(uint8_t *b, uint8_t* arr, int n){
  for(int i = 0; i < n; i++){
    if(b[i] != arr[i]){
      return false;
    }
  }
  return true;
}

void test_rb_heap_stack(void){
  ringbuffer_t rb_heap, rb_stack;

  rb_create(&rb_heap, RB_SIZE);
  rb_init(&rb_stack, _rb_stack, RB_SIZE);

  uint64_t t1, t2, t3;
  
  for(int i = 0; i < TEST_ARR_LENGTH; i++){
    input[i] = rand() % 256;
  }

  t1 = systemTimeGetUs();
  
  rb_put(&rb_heap, input, TEST_ARR_LENGTH);
  
  t2 = systemTimeGetUs();

  rb_put(&rb_stack, input, TEST_ARR_LENGTH);

  t3 = systemTimeGetUs();

  NRF_LOG_RAW_INFO("[main] RB HEAP TEST ")
  if(test_rb_check(&rb_heap, input)){
    NRF_LOG_RAW_INFO("SUCCEEDED ")
  }else{
   NRF_LOG_RAW_INFO("FAILED ")
  }
  NRF_LOG_RAW_INFO("Time taken: %d\n", t2 - t1)
  
  NRF_LOG_RAW_INFO("[main] RB STACK TEST ")
  
  if(test_rb_check(&rb_stack, input)){
    NRF_LOG_RAW_INFO("SUCCEEDED ")
  }else{
    NRF_LOG_RAW_INFO("FAILED ")
  }
  NRF_LOG_RAW_INFO("Time taken: %d\n", t3 - t2)  
}

void test_rb_put_get_speed(void){
  ringbuffer_t rb;
  rb_init(&rb, _rb_stack, RB_SIZE);
  
  for(int i = 0; i < TEST_ARR_LENGTH; i++){
    input[i] = rand() % 256;
  }

  uint64_t t1, t2, t3;
  t1 = systemTimeGetUs();
  
  for(int i = 0; i < 10; i++){
    rb_put(&rb, input, TEST_ARR_LENGTH);
    for(int j = 0; j < TEST_ARR_LENGTH; j++){
      output[j] = rb_at(&rb, j);
    }
    rb_advance(&rb, TEST_ARR_LENGTH);
  }
  
  t2 = systemTimeGetUs();  
  NRF_LOG_RAW_INFO("[main] RB PUTGET SLOW ")
  if(test_arrays_equal(output, input, TEST_ARR_LENGTH)){
    NRF_LOG_RAW_INFO("SUCCEEDED ")
  }else{
    NRF_LOG_RAW_INFO("FAILED ")
  }
  NRF_LOG_RAW_INFO("Time taken: %d\n", t2 - t1)\
  
  rb_reset(&rb);
  t2 = systemTimeGetUs();

   for(int i = 0; i < 10; i++){
    rb_put(&rb, input, TEST_ARR_LENGTH);
    rb_get_fast(&rb, output, TEST_ARR_LENGTH);
    rb_advance(&rb, TEST_ARR_LENGTH);
  }

  t3 = systemTimeGetUs();
  NRF_LOG_RAW_INFO("[main] RB PUTGET FAST ")
  if(test_arrays_equal(output, input, TEST_ARR_LENGTH)){
    NRF_LOG_RAW_INFO("SUCCEEDED ")
  }else{
    NRF_LOG_RAW_INFO("FAILED ")
  }
  NRF_LOG_RAW_INFO("Time taken: %d\n", t3 - t2)  
}

void test_rb_put_get(void){
  ringbuffer_t rb;
  uint32_t n;
  rb_init(&rb, _rb_stack, RB_SIZE);
  
  uint64_t t1, t2;
  bool succ = 1;
  t1 = systemTimeGetUs();
  for(int t = 0; t < 100; t++){
    n = rand() % TEST_ARR_LENGTH;
    for(int i = 0; i < n; i++){
      input[i] = rand() % 256;
    }
    rb_put(&rb, input, n);
    rb_get_fast(&rb, output, n);
    succ = succ && test_arrays_equal(output, input, n);
    rb_advance(&rb, n);
  }
  t2 = systemTimeGetUs();

  NRF_LOG_RAW_INFO("[main] RB PUTGET TEST ")
  if(succ){
    NRF_LOG_RAW_INFO("SUCCEEDED ")
  }else{
    NRF_LOG_RAW_INFO("FAILED ")
  }
  NRF_LOG_RAW_INFO("Time taken: %d\n", t2 - t1)  
}

#endif

int main(void){
    // Initialize.
    log_init();

    ret_code_t ret = nrf_drv_clock_init();
    APP_ERROR_CHECK(ret);
    
    nrf_drv_clock_lfclk_request(NULL);

    while(!nrf_drv_clock_lfclk_is_running())
    {
        /* Just waiting */
    }

    timersInit();
    
    //uart_init();
    uint32_t retcode = usb_init();
    APP_ERROR_CHECK(retcode);
    
    buttons_leds_init();
    power_management_init();
    
    eventQueueInit();

    ble_init();

#if RUN_TESTS
    test_rb_heap_stack();
    test_rb_put_get_speed();
    test_rb_put_get();
#endif

    // Enter main loop.
    for (;;)
    {
        while(app_usbd_event_queue_process()){}
        idle_state_handle();
        processQueue();
    }
}

void processQueue(void){
  if (!eventQueueEmpty()) {
    event_t event = eventQueueFront();
    switch(event.type) {
      case EVENT_BLE_SEND_DATA_DONE:
        NRF_LOG_RAW_INFO("%08d [main] TX DONE\n",  systemTimeGetUs());
        if(!ble_write_buffer_empty()){
          ble_cus_attempt_transmit(false);
        }else if(m_ble_tx_sent_requested){
          ble_cus_write_tx_finished();
          m_ble_tx_sent_requested = false;
        }
      break;
      case EVENT_DATABASE_DISCOVERY_COMPLETE:
        NRF_LOG_RAW_INFO("%08d [main] There are now %d devices connected!\n", systemTimeGetMs(), ble_get_device_count());
        
        if(ble_get_device_count() < NRF_SDH_BLE_CENTRAL_LINK_COUNT
           && !ble_cus_scan_stopped()){
           scan_start();
        }
      break;
      case EVENT_TIMERS_ONE_SECOND_ELAPSED:{
        //if(ble_write_buffer_empty()){
        //  NRF_LOG_RAW_INFO("%08d [main] TX IS FINISHED\n",  systemTimeGetUs());
        //}
        //uint8_t message[] = "One second has passed!";
        //uint16_t length = strlen(message);
        //if(usb_write(USB_BLE_INFO, message, length)){
        //  NRF_LOG_RAW_INFO("USB WRITE SUCCESSFUL\n");
        //}
        //usb_attempt_transmit();
      }
      break;
      case EVENT_USB_CONNECTED:{
        uint8_t byte = 0xFF;
        delayMs(100);
        usb_write(USB_INFO, &byte, 1);
        NRF_LOG_INFO("Sent data");
      }
      break;
      case EVENT_USB_DISCONNECTED:{
        NRF_LOG_INFO("Disconnected, now deleting all peripherals");
        for(int i = 0; i < NRF_SDH_BLE_CENTRAL_LINK_COUNT; i++){
          ble_cus_t *p_cus = ble_cus_get_service();
          if(p_cus->ble_device_list[i] != NULL){
            sd_ble_gap_disconnect(p_cus->ble_device_list[i]->conn_handle, BLE_HCI_REMOTE_USER_TERMINATED_CONNECTION);
            NRF_LOG_INFO("Disconnected peripheral %d", p_cus->ble_device_list[i]->conn_handle);
            //ble_cus_remove_device(&m_cus, m_cus.ble_device_list[i]->conn_handle);
          }
        }
        scan_stop();
        while(!eventQueueEmpty()){
          NRF_LOG_INFO("Popping event from queue");
          eventQueuePop();
        }
        event_t ev = {EVENT_USB_DISCONNECTED};
        eventQueuePush(ev); // So it will be taken out later

        NVIC_SystemReset();
      } 
      break;
      case EVENT_USB_DATA_READ:{
        if(usb_available() >= METADATA_SIZE){
          usb_packet_type_t type = usb_get();
          uint16_t length = (usb_get() << 8) | usb_get();
    
          //NRF_LOG_INFO("packet type: %d\t length: %d\n", type, length);

          if(length > 0){
            for(int i = 0; i < length; i++) usb_args_buffer[i] = usb_get();
          }

          if(type == USB_BLE_COMMAND){
            uint8_t *p_args = usb_args_buffer;
            usb_ble_command_type_t ble_cmd_type = *p_args++;//length--;
            //NRF_LOG_INFO("command type: %d", cmd_type);
            switch(ble_cmd_type){
              case BLE_SCAN_START: {
                scan_start();
                NRF_LOG_RAW_INFO("%08d [main] Scanning started!\n", systemTimeGetMs());
              }
              break;
              case BLE_SCAN_STOP:{
                scan_stop();
                NRF_LOG_RAW_INFO("%08d [main] Scanning stopped!\n", systemTimeGetMs());
              }
              break;
              case BLE_TX_AWAIT_FINISHED:{
                if(!ble_write_buffer_empty()){
                  m_ble_tx_sent_requested = true;
                  NRF_LOG_RAW_INFO("%08d [main] TX DONE Requested\n",  systemTimeGetUs());
                }else{
                  ble_cus_write_tx_finished();
                }
              }
              break;
              case BLE_GATT_REQUEST:{
                uint16_t robot_id = (*p_args++ << 8) + *p_args++;//length-=2;
                usb_ble_gatt_request_type_t gatt_req_type = *p_args++;//length--;
                uint16_t characteristic_uuid = (*p_args++ << 8) + *p_args++;//length-=2;
                
                switch(gatt_req_type){
                  case BLE_START_NOTIFICATIONS:{
                    cccd_configure(robot_id, characteristic_uuid, true, false);
                  }
                  break;
                  
                  case BLE_STOP_NOTIFICATIONS:{
                    cccd_configure(robot_id, characteristic_uuid, false, false);
                  break;
                  }
                  
                  case BLE_WRITE_CHARACTERISTIC:{
                    NRF_LOG_RAW_INFO("%08d [main] Writing to characteristic %d length %d: %d!\n", systemTimeGetUs(), characteristic_uuid, length-(p_args - usb_args_buffer), p_args[0]);
                    ble_cus_write_char(robot_id, characteristic_uuid,
                                       p_args, length-(p_args - usb_args_buffer));
                  break;
                  }
                  
                  case BLE_READ_CHARACTERISTIC:{
                    // TODO: Implement
                  break;
                  }
                }
              }
              break;
              
              default:
              break;
            }
          }else{
            NRF_LOG_RAW_INFO("Unhandled usb command type: %d", type);
          }
        }
      }
      break;

      default:
      NRF_LOG_RAW_INFO("%08d [main] unhandled event:%d\n", systemTimeGetMs(), eventQueueFront().type);
      break;
    }
    eventQueuePop();
  }
}